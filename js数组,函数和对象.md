# 数组

## 创建数组

```js
    var arr = new Array()//方式一
    //()里可以填参数

    var arr1 = [1, 2, 3, 4, 5];//方式二
 ```

## 数组元素的增删改查

1. 表示数组长度 length表示 `变量名.length`
  - 对于连续的数组，使用 length 可以获取到数组的长度（元素的个数）
  - 对于非连续的数组,会得到最大的索引+1,因此最好不要使用非连续的数组

2. 索引:数组中每个元素的编号 这里0,1,2,3 咱们称之为数组的 索引  (下标)
  - 可以使用下标查找一个元素
  ```js
  console.log(arr[1]);
  console.log(arr[arr.length - 1]);
   // 如果读取不存在的索引（比如元素没那么多），系统不会报错，而是返回 undefined。
  ```
  - 使用索引 添加(追加)元素
  ```js
    var arr1 = new Array();
    arr1[0] = 20;
    arr1[1] = 30;
    // arr1[4] = 60;
    // 在数组末尾加一个元素
  ```
  - 使用索引可以修改元素
  ```js
    var arr = [1,2,3,4,5]
    arr[0] = 5;
    arr[1] = 10;
  ```

## 遍历数组元素

```js
    var arr = ['小明', '小红', '小王', '小张'];
    // 实现打印 出 这个数组里边 所有的元素
    // console.log(arr[0]);
    // console.log(arr[1]);
    // ... 
    // 最后一个元素
    // console.log(arr[arr.length-1]);
    for (var i = 0; i < arr.length; i++) {
        console.log(arr[i]);
    }

    console.log(movies);
```

## 求数组平均值

```js
    var arr = [32, 41, 1, 40, 12, 5];
        // 先求和  再求平均
        var sum = 0;//计数器
        for (var i = 0; i < arr.length; i++) {
            sum = sum + arr[i];//每次循环完会和上次的值相加最后求出和
        }
        // console.log(sum);
        var average = sum / arr.length;
        console.log(average);
```

## 数组的基本方法

1. `shift()` 从前删除 ,删除第一个元素,返回值 是 删除的 那个元素,修改了原数组

2. `pop()` 从后删除,删除最后一个元素,返回值是删除的那个元素,修改了数组

3. `push()` 添加一个元素,从后添加.返回值的添加之后数组的长度,修改了数组

4. `unshift()` 添加一个元素,从前添加.返回添加之后数组的长度,修改了数组

5. `concat()` 连接两个或者多个数组,返回结果为新数组,不会改变原数组

6. `join()` 将数组转换成字符串,返回结果为转换后的字符串,可以指定一个字符串作为参数,这个字符串会成为新数组中元素的连接符
如果不指示 默认以 , 作为连接

7. split()： 通过指定分隔符， 如果省略， 默认以逗号分隔， 将字符串分割为字符串数组。
     - 第二个参数，制定返回数组的最大长度。

## 冒泡排序

1. 冒泡排序
   - 比较相邻的元素。 如果第一个比第二个大， 就交换他们两个。
   - 对每一对相邻元素作同样的工作， 从开始第一对到结尾的最后一对。 在这一点， 最后的元素应该会是最大的数。
   - 针对所有的元素重复以上的步骤， 除了最后一个。
   - 持续每次对越来越少的元素重复上面的步骤， 直到没有任何一对数字需要比较。
   - 之所以叫冒泡排序， 每一轮两两比较之后， 都会冒出一个本轮最大的数， 将其移动到本轮尾部。
```js
var arr = [41, 32, 1, 40, 12, 5];
for (var j = 0; j < arr.length - 1; j++) {
    // 外层循环 控制轮次,arr.length-1次
    // 每执行完一趟之后,内层循环都可以少比较一次
    for (var i = 0; i < arr.length - 1 - j; i++) {
        // arr[i]和 arr[i+1]]
        if (arr[i] > arr[i + 1]) {
            // 交换位置
            // arr[i] = arr[i + 1];
            // arr[i + 1] = arr[i];
            var temp = arr[i];
            arr[i] = arr[i + 1];
            arr[i + 1] = temp;
                }
            }
            // console.log(arr);
        }
        console.log(arr);
```

## 选择排序

1. 选择排序
    选择排序是一种简单直观的排序算法。
    它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，
    然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
    以此类推，直到全部待排序的数据元素排完。
    选择排序是不稳定的排序方法。

```js
var arr = [41, 32, 1, 40, 12, 5];
for (var j = 0; j < arr.length - 1; j++) {
    var minIndex = j;
    for (var i = j + 1; i < arr.length; i++) {
        if (arr[minIndex] > arr[i]) {
                    minIndex = i;
        }
    }
    if (minIndex !== j) {
        var temp = arr[j];
        arr[j] = arr[minIndex];
        arr[minIndex] = temp;
    }
     console.log(arr);
}
```

## 插入排序

+ 插入排序
   - 从第一个元素开始，该元素可以认为已经被排序；
   - 取出下一个元素，在已经排序的元素序列中从后向前扫描；
   - 如果该元素（已排序）大于新元素，将该元素移到下一位置；
   - 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；
   - 将新元素插入到该位置后；
   - 重复步骤 2~5。

```js
var arr = [41, 32, 1, 40, 12, 5];
        // for (var i = 1; i < arr.length; i++) {
        //     var j = i - 1;
        //     while(){

        //     }
        //     if (arr[i] < arr[j]) {
        //         arr[j + 1] = arr[j];
        //     }
        // }
        var len = arr.length;
        for (var i = 1; i < len; i++) {
            var j = i - 1;
            var temp = arr[i];
            while (j >= 0 && temp < arr[j]) {
                arr[j + 1] = arr[j];
                // [41, 41, 1, 40, 12, 5]
                j--;
            }
            arr[j + 1] = temp;
            // [32, 41, 1, 40, 12, 5]
            // [1,32,41,40,12,5]
            // [1,32,40,41,12,5]
            // [1,12,32,40,41,5]
            // [1,5,12,32,40,41]
            console.log(arr);
        }
        // console.log(arr);
        // loadsh

```
# 函数

## 函数

* 函数：就是将一些功能或语句进行封装，在需要的时候，通过调用的形式，执行这些语句。

## 创建函数

1. 具名函数
```js
function say(){
    //要执行的语句
}
```

2. 匿名函数
```js
var foo = function () {
            alert('匿名函数');
 }
```

3. 自执行函数(创建时立即执行)
```js
;
(function () {
alert('我是一个自执行函数');
})()
```
4. 函数创建完不调用不会执行   调用函数  函数名()

## 函数的参数

1. 形参:创建函数时括号里的值,不调用时,并不知道它代表什么,占位用的

2. 实参:调用函数时括号里的值,会对对应的形参进行赋值

## 函数的返回值

1. 函数的返回值 ,就是函数执行的结果(并不是他做了什么事情)

2. 默认的返回值 是undefined

3. 想拿到函数的返回值可以使用`return` return 出去的 数据 可以是任意的数据类型  包括 对象 和 函数
  - 注意的是 函数 return  后边的 语句代码 不再执行

## 作用域

作用域指一个变量的作用范围。 在 js 中， 一共有两种作用域

1. 全局作用域
  - 在全局作用域中
    - 创建的变量都会作为 window 对象的属性保存
    - 创建的函数都会作为 window 对象的方法保存

2. 函数作用域
  - 在函数作用中只能在函数中使用

## 作用域的上下级关系

变量的查找规则
  - 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用（就近原则）。如果没有则向上一级作用域中寻找，直到找到全局作用域；
    如果全局作用域中依然没有找到，则会报错 ReferenceError。
  - 也就是说子级的变量只能在子级(或者更低级)的作用域中使用 他的父级无法使用;

## 声明提升

1. 变量声明的提升:
  - 使用 var 关键字声明的变量（ 比如 var a = 1），会在所有的代码执行之前被声明（但是不会赋值）
  - 但是如果声明变量时不是用 var 关键字（比如直接写 a = 1），则变量不会被声明提前。

2. 函数声明的提升:
  - 使用函数声明的形式创建的函数 function foo(){}，会被声明提前。
    也就是说，整个函数会在所有的代码执行之前就被创建完成，所以我们可以在函数声明之前，调用函数。
  - 使用函数表达式创建的函数 var foo = function(){}，不会被声明提前，所以不能在声明前调用。

## 函数参数的数据类型

1. 栈内存和堆内存
  - 所有的变量都储存在栈内存 只不过基本数据类型的值直接保存 引入数据类型的值保存的是一个地址指向实际的数组(堆内存当中存放)
  - 引入数据类型的实际数组都保存在堆内存中

2. 调用函数实参赋值时如果赋给的是基本数据类型 则不会改变这个变量的值

3. 调用函数实参赋值时如果赋给的时引用数据类型 就会改变这个变量原有的值(多赋给的会增加,少赋给的会减少)

## 递归 

递归是一种编程模式，用于一个任务可以被分割为多个相似的更简单的任务的场景。
当一个函数解决一个任务时，在该过程中它可以调用很多其它函数。那么当一个函数调用自身时，就称其为递归
```js
//求x的n次方
function pow(x, n) {
	if (n == 1) {
		return x;
	} else {
		return x * pow(x, n - 1);
	}
}

alert(pow(2, 3)); // 8
```
# 对象

1. 对象是用来描述事物封装信息.

2. 对象包括属性和方法(是函数)

3. 如果两个变量引用的是同一个对象 当修改一个变量时 另一个也会受影响

## 对象的创建

1. 方法一:借助构造函数:
使用 new 关键字调用的函数，是构造函数 constructor。构造函数是专门用来创建对象的函数
```js
var obj = new Object();
```

2. 方式二:字面量;
  - 属性名和属性值是一组一组的键值对结构，键和值之间使用:连接，多个值对之间使用,隔开。
  - 如果一个属性之后没有其他的属性了，就不要写,，因为它是对象的最后一个属性。
```js
var obj2 = {
   name: '小明',
   sex: '男',
   say: function () {
       alert('你好')
   } }
```
3. 查看属性 对象名.属性名

4. 修改属性 对象名.属性名=修改的数据

5. 增加属性 对象名.新增的属性名=新增的属性值

6. 删除属性 delete 对象名.属性名

## 遍历对象

遍历对象使用for in
```js
// for in 循环 遍历对象 
for (var key in user) {
    // key  指的是 你遍历到的 每个 属性名
    console.log(key); // name  age...
    console.log(user.key); // undefined ,没有key 属性 ,,  . 后边跟的 字符,不会被当做变量解析
    // 属性名是动态的(或者说想让属性名被当做变量解析,那你需要使用[])
    console.log(user[key]);
}
```

## 构造函数
```js
 // 自定义构造函数 取 创建一个对象
function Student(name, sex) {
    this.level = '七年级';
    this.school = '不凡';
    this.name = name;
    this.sex = sex;
    this.say = function () {
        // 在new 的时候 这里边 的 this  不会被解析
        alert(this.name);
    }
}
//我们可以根据这个构造函数来 new 新的对象
var user1 = new Student('小明', '男');
var user2 = new Student('小红', '女');

```
* ` this `的作用:
  - 指向调用者,通常是 . 前边的对象
  - 对于构造函数而言 ,指向new出来的实例对象 

* ` new `的作用:
  - 在函数中 创建了一个空对象 {}
  - 将 函数中  this  指向 创建出来的 {}(空对象)
  - 执行里边的代码 (追加属性)
  - 将追加好属性的  对象  return 出去

* 补充 :  this 的指向 我们是可以强行修改(call,apply...)

## json对象的两个方法

* `json`是一种数据传输格式,目前比较流行 这是一个对象 我们通过他的两个方法来改变数据类型从而达到在互联网中的数据的传输

* `JSON.stringify()` 是把对象转换成字符串的形式

* `SON.parse()` 把从后台拿到的数据转换成对象

* ```js
  var str = '{a: "Hello", b: "World"}';
  //这种直接在对象两边加上的引号转变成的字符串没有办法变成对象
  console.log(JSON.parse(str)); // 报错
  ```

## 数组的高级方法

1. `reverse()`：反转数组，返回结果为反转后的数组（会改变原来的数组）。

2. ` sort()`： 对数组的元素进行从小到大来排序（ 会改变原来的数组）。
  - 如果在使用 sort() 方法时不带参， 则默认按照Unicode 编码， 从小到大进行排序。
  - 如果在 sort()方法中带参，我们就可以自定义排序规则。
  ```js
  arr3.sort(function(a, b) {
		 // 指定排序规则
		 // 从小到大排
		 return a - b;
		 // 根据回调函数的返回值来决定元素的排序：（ 重要）
		 // 如果返回一个大于 0 的值， 则元素会交换位置
		 // 如果返回一个小于 0 的值， 则元素位置不变
		 // 如果返回一个 0， 则认为两个元素相等， 则不交换位置

		 // 想  从大到小排
		 // return b - a;
	 });
  ```

3. `slice()`：从数组中提取指定的一个或者多个元素，返回结果为新的数组（不会改变原来的数组）。

4. `splice()`  替换或者删除

5. `indexOf()` 和 `lastIndexOf()`：获取数据的索引
  - `indexof()`是从前 匹配,找到之后不再匹配,然后返回匹配值的下标
  - `lastIndexof()`是从后匹配,找到之后不再匹配,然后返回匹配值得下边

6. `forEach()` 可以遍历数组
  ```js
   // 回调函数内  第一个参数 表示遍历到的元素 ,第二个参数表示其对应的下标
    arr5.forEach(function (item, index) {
        console.log(index, item);
      });
  ```

7. 怎么学习 一个  方法  或者 api
  1. 了解方法的作用,用来干什么,语法
  2. 需要哪些参数,参数的 数据类型是什么
  3. 返回值

## 字符串的方法

* `charAt()` 获取相应位置的字符

* `charCodeAt()` 指定位置字符 的 Unicode 编码

* `indexOf()` 返回字符在字符串中的位置

* `lastIndexOf()`

* `concat()` 连接字符串

* `slice()` 提取字符串的某个部分

* `substr()` 截取字符串

* `toUpperCase()`变成大写

* `toLowerCase()`变成小写




