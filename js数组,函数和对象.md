# 数组

## 创建数组

```js
    var arr = new Array()//方式一
    //()里可以填参数

    var arr1 = [1, 2, 3, 4, 5];//方式二
 ```

## 数组元素的增删改查

1. 表示数组长度 length表示 `变量名.length`
  - 对于连续的数组，使用 length 可以获取到数组的长度（元素的个数）
  - 对于非连续的数组,会得到最大的索引+1,因此最好不要使用非连续的数组

2. 索引:数组中每个元素的编号 这里0,1,2,3 咱们称之为数组的 索引  (下标)
  - 可以使用下标查找一个元素
  ```js
  console.log(arr[1]);
  console.log(arr[arr.length - 1]);
   // 如果读取不存在的索引（比如元素没那么多），系统不会报错，而是返回 undefined。
  ```
  - 使用索引 添加(追加)元素
  ```js
    var arr1 = new Array();
    arr1[0] = 20;
    arr1[1] = 30;
    // arr1[4] = 60;
    // 在数组末尾加一个元素
  ```
  - 使用索引可以修改元素
  ```js
    var arr = [1,2,3,4,5]
    arr[0] = 5;
    arr[1] = 10;
  ```

## 遍历数组元素

```js
    var arr = ['小明', '小红', '小王', '小张'];
    // 实现打印 出 这个数组里边 所有的元素
    // console.log(arr[0]);
    // console.log(arr[1]);
    // ... 
    // 最后一个元素
    // console.log(arr[arr.length-1]);
    for (var i = 0; i < arr.length; i++) {
        console.log(arr[i]);
    }

    console.log(movies);
```

## 求数组平均值

```js
    var arr = [32, 41, 1, 40, 12, 5];
        // 先求和  再求平均
        var sum = 0;//计数器
        for (var i = 0; i < arr.length; i++) {
            sum = sum + arr[i];//每次循环完会和上次的值相加最后求出和
        }
        // console.log(sum);
        var average = sum / arr.length;
        console.log(average);
```

## 数组的基本方法

1. `shift()` 从前删除 ,删除第一个元素,返回值 是 删除的 那个元素,修改了原数组

2. `pop()` 从后删除,删除最后一个元素,返回值是删除的那个元素,修改了数组

3. `push()` 添加一个元素,从后添加.返回值的添加之后数组的长度,修改了数组

4. `unshift()` 添加一个元素,从前添加.返回添加之后数组的长度,修改了数组

5. `concat()` 连接两个或者多个数组,返回结果为新数组,不会改变原数组

6. `join()` 将数组转换成字符串,返回结果为转换后的字符串,可以指定一个字符串作为参数,这个字符串会成为新数组中元素的连接符
如果不指示 默认以 , 作为连接

7. split()： 通过指定分隔符， 如果省略， 默认以逗号分隔， 将字符串分割为字符串数组。
     - 第二个参数，制定返回数组的最大长度。

## 冒泡排序

1. 冒泡排序
   - 比较相邻的元素。 如果第一个比第二个大， 就交换他们两个。
   - 对每一对相邻元素作同样的工作， 从开始第一对到结尾的最后一对。 在这一点， 最后的元素应该会是最大的数。
   - 针对所有的元素重复以上的步骤， 除了最后一个。
   - 持续每次对越来越少的元素重复上面的步骤， 直到没有任何一对数字需要比较。
   - 之所以叫冒泡排序， 每一轮两两比较之后， 都会冒出一个本轮最大的数， 将其移动到本轮尾部。
```js
var arr = [41, 32, 1, 40, 12, 5];
for (var j = 0; j < arr.length - 1; j++) {
    // 外层循环 控制轮次,arr.length-1次
    // 每执行完一趟之后,内层循环都可以少比较一次
    for (var i = 0; i < arr.length - 1 - j; i++) {
        // arr[i]和 arr[i+1]]
        if (arr[i] > arr[i + 1]) {
            // 交换位置
            // arr[i] = arr[i + 1];
            // arr[i + 1] = arr[i];
            var temp = arr[i];
            arr[i] = arr[i + 1];
            arr[i + 1] = temp;
                }
            }
            // console.log(arr);
        }
        console.log(arr);
```

## 选择排序

1. 选择排序
    选择排序是一种简单直观的排序算法。
    它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，
    然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
    以此类推，直到全部待排序的数据元素排完。
    选择排序是不稳定的排序方法。

```js
var arr = [41, 32, 1, 40, 12, 5];
for (var j = 0; j < arr.length - 1; j++) {
    var minIndex = j;
    for (var i = j + 1; i < arr.length; i++) {
        if (arr[minIndex] > arr[i]) {
                    minIndex = i;
        }
    }
    if (minIndex !== j) {
        var temp = arr[j];
        arr[j] = arr[minIndex];
        arr[minIndex] = temp;
    }
     console.log(arr);
}
```

## 插入排序

+ 插入排序
   - 从第一个元素开始，该元素可以认为已经被排序；
   - 取出下一个元素，在已经排序的元素序列中从后向前扫描；
   - 如果该元素（已排序）大于新元素，将该元素移到下一位置；
   - 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；
   - 将新元素插入到该位置后；
   - 重复步骤 2~5。

```js
var arr = [41, 32, 1, 40, 12, 5];
        // for (var i = 1; i < arr.length; i++) {
        //     var j = i - 1;
        //     while(){

        //     }
        //     if (arr[i] < arr[j]) {
        //         arr[j + 1] = arr[j];
        //     }
        // }
        var len = arr.length;
        for (var i = 1; i < len; i++) {
            var j = i - 1;
            var temp = arr[i];
            while (j >= 0 && temp < arr[j]) {
                arr[j + 1] = arr[j];
                // [41, 41, 1, 40, 12, 5]
                j--;
            }
            arr[j + 1] = temp;
            // [32, 41, 1, 40, 12, 5]
            // [1,32,41,40,12,5]
            // [1,32,40,41,12,5]
            // [1,12,32,40,41,5]
            // [1,5,12,32,40,41]
            console.log(arr);
        }
        // console.log(arr);
        // loadsh

```