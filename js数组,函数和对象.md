# 数组

## 创建数组

```js
    var arr = new Array()//方式一
    //()里可以填参数

    var arr1 = [1, 2, 3, 4, 5];//方式二
 ```

## 数组元素的增删改查

1. 表示数组长度 length表示 `变量名.length`
  - 对于连续的数组，使用 length 可以获取到数组的长度（元素的个数）
  - 对于非连续的数组,会得到最大的索引+1,因此最好不要使用非连续的数组

2. 索引:数组中每个元素的编号 这里0,1,2,3 咱们称之为数组的 索引  (下标)
  - 可以使用下标查找一个元素
  ```js
  console.log(arr[1]);
  console.log(arr[arr.length - 1]);
   // 如果读取不存在的索引（比如元素没那么多），系统不会报错，而是返回 undefined。
  ```
  - 使用索引 添加(追加)元素
  ```js
    var arr1 = new Array();
    arr1[0] = 20;
    arr1[1] = 30;
    // arr1[4] = 60;
    // 在数组末尾加一个元素
  ```
  - 使用索引可以修改元素
  ```js
    var arr = [1,2,3,4,5]
    arr[0] = 5;
    arr[1] = 10;
  ```

## 遍历数组元素

```js
    var arr = ['小明', '小红', '小王', '小张'];
    // 实现打印 出 这个数组里边 所有的元素
    // console.log(arr[0]);
    // console.log(arr[1]);
    // ... 
    // 最后一个元素
    // console.log(arr[arr.length-1]);
    for (var i = 0; i < arr.length; i++) {
        console.log(arr[i]);
    }

    console.log(movies);
```

## 求数组平均值

```js
    var arr = [32, 41, 1, 40, 12, 5];
        // 先求和  再求平均
        var sum = 0;//计数器
        for (var i = 0; i < arr.length; i++) {
            sum = sum + arr[i];//每次循环完会和上次的值相加最后求出和
        }
        // console.log(sum);
        var average = sum / arr.length;
        console.log(average);
```

## 数组的基本方法

1. `shift()` 从前删除 ,删除第一个元素,返回值 是 删除的 那个元素,修改了原数组

2. `pop()` 从后删除,删除最后一个元素,返回值是删除的那个元素,修改了数组

3. `push()` 添加一个元素,从后添加.返回值的添加之后数组的长度,修改了数组

4. `unshift()` 添加一个元素,从前添加.返回添加之后数组的长度,修改了数组

5. `concat()` 连接两个或者多个数组,返回结果为新数组,不会改变原数组

6. `join()` 将数组转换成字符串,返回结果为转换后的字符串,可以指定一个字符串作为参数,这个字符串会成为新数组中元素的连接符
如果不指示 默认以 , 作为连接

7. split()： 通过指定分隔符， 如果省略， 默认以逗号分隔， 将字符串分割为字符串数组。
     - 第二个参数，制定返回数组的最大长度。

## 冒泡排序

1. 冒泡排序
   - 比较相邻的元素。 如果第一个比第二个大， 就交换他们两个。
   - 对每一对相邻元素作同样的工作， 从开始第一对到结尾的最后一对。 在这一点， 最后的元素应该会是最大的数。
   - 针对所有的元素重复以上的步骤， 除了最后一个。
   - 持续每次对越来越少的元素重复上面的步骤， 直到没有任何一对数字需要比较。
   - 之所以叫冒泡排序， 每一轮两两比较之后， 都会冒出一个本轮最大的数， 将其移动到本轮尾部。
```js
var arr = [41, 32, 1, 40, 12, 5];
for (var j = 0; j < arr.length - 1; j++) {
    // 外层循环 控制轮次,arr.length-1次
    // 每执行完一趟之后,内层循环都可以少比较一次
    for (var i = 0; i < arr.length - 1 - j; i++) {
        // arr[i]和 arr[i+1]]
        if (arr[i] > arr[i + 1]) {
            // 交换位置
            // arr[i] = arr[i + 1];
            // arr[i + 1] = arr[i];
            var temp = arr[i];
            arr[i] = arr[i + 1];
            arr[i + 1] = temp;
                }
            }
            // console.log(arr);
        }
        console.log(arr);
```

## 选择排序

1. 选择排序
    选择排序是一种简单直观的排序算法。
    它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，
    然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
    以此类推，直到全部待排序的数据元素排完。
    选择排序是不稳定的排序方法。

```js
var arr = [41, 32, 1, 40, 12, 5];
for (var j = 0; j < arr.length - 1; j++) {
    var minIndex = j;
    for (var i = j + 1; i < arr.length; i++) {
        if (arr[minIndex] > arr[i]) {
                    minIndex = i;
        }
    }
    if (minIndex !== j) {
        var temp = arr[j];
        arr[j] = arr[minIndex];
        arr[minIndex] = temp;
    }
     console.log(arr);
}
```

## 插入排序

+ 插入排序
   - 从第一个元素开始，该元素可以认为已经被排序；
   - 取出下一个元素，在已经排序的元素序列中从后向前扫描；
   - 如果该元素（已排序）大于新元素，将该元素移到下一位置；
   - 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；
   - 将新元素插入到该位置后；
   - 重复步骤 2~5。

```js
var arr = [41, 32, 1, 40, 12, 5];
        // for (var i = 1; i < arr.length; i++) {
        //     var j = i - 1;
        //     while(){

        //     }
        //     if (arr[i] < arr[j]) {
        //         arr[j + 1] = arr[j];
        //     }
        // }
        var len = arr.length;
        for (var i = 1; i < len; i++) {
            var j = i - 1;
            var temp = arr[i];
            while (j >= 0 && temp < arr[j]) {
                arr[j + 1] = arr[j];
                // [41, 41, 1, 40, 12, 5]
                j--;
            }
            arr[j + 1] = temp;
            // [32, 41, 1, 40, 12, 5]
            // [1,32,41,40,12,5]
            // [1,32,40,41,12,5]
            // [1,12,32,40,41,5]
            // [1,5,12,32,40,41]
            console.log(arr);
        }
        // console.log(arr);
        // loadsh

```
# 函数

## 函数

* 函数：就是将一些功能或语句进行封装，在需要的时候，通过调用的形式，执行这些语句。

## 创建函数

1. 具名函数
```js
function say(){
    //要执行的语句
}
```

2. 匿名函数
```js
var foo = function () {
            alert('匿名函数');
 }
```

3. 自执行函数(创建时立即执行)
```js
;
(function () {
alert('我是一个自执行函数');
})()
```
4. 函数创建完不调用不会执行   调用函数  函数名()

## 函数的参数

1. 形参:创建函数时括号里的值,不调用时,并不知道它代表什么,占位用的

2. 实参:调用函数时括号里的值,会对对应的形参进行赋值

## 函数的返回值

1. 函数的返回值 ,就是函数执行的结果(并不是他做了什么事情)

2. 默认的返回值 是undefined

3. 想拿到函数的返回值可以使用`return` return 出去的 数据 可以是任意的数据类型  包括 对象 和 函数
  - 注意的是 函数 return  后边的 语句代码 不再执行

## 作用域

作用域指一个变量的作用范围。 在 js 中， 一共有两种作用域

1. 全局作用域
  - 在全局作用域中
    - 创建的变量都会作为 window 对象的属性保存
    - 创建的函数都会作为 window 对象的方法保存

2. 函数作用域
  - 在函数作用中只能在函数中使用

## 作用域的上下级关系

变量的查找规则
  - 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用（就近原则）。如果没有则向上一级作用域中寻找，直到找到全局作用域；
    如果全局作用域中依然没有找到，则会报错 ReferenceError。
  - 也就是说子级的变量只能在子级(或者更低级)的作用域中使用 他的父级无法使用;

## 声明提升

1. 变量声明的提升:
  - 使用 var 关键字声明的变量（ 比如 var a = 1），会在所有的代码执行之前被声明（但是不会赋值）
  - 但是如果声明变量时不是用 var 关键字（比如直接写 a = 1），则变量不会被声明提前。

2. 函数声明的提升:
  - 使用函数声明的形式创建的函数 function foo(){}，会被声明提前。
    也就是说，整个函数会在所有的代码执行之前就被创建完成，所以我们可以在函数声明之前，调用函数。
  - 使用函数表达式创建的函数 var foo = function(){}，不会被声明提前，所以不能在声明前调用。

## 函数参数的数据类型

1. 栈内存和堆内存
  - 所有的变量都储存在栈内存 只不过基本数据类型的值直接保存 引入数据类型的值保存的是一个地址指向实际的数组(堆内存当中存放)
  - 引入数据类型的实际数组都保存在堆内存中

2. 调用函数实参赋值时如果赋给的是基本数据类型 则不会改变这个变量的值

3. 调用函数实参赋值时如果赋给的时引用数据类型 就会改变这个变量原有的值(多赋给的会增加,少赋给的会减少)

## 递归 

递归是一种编程模式，用于一个任务可以被分割为多个相似的更简单的任务的场景。
当一个函数解决一个任务时，在该过程中它可以调用很多其它函数。那么当一个函数调用自身时，就称其为递归
```js
//求x的n次方
function pow(x, n) {
	if (n == 1) {
		return x;
	} else {
		return x * pow(x, n - 1);
	}
}

alert(pow(2, 3)); // 8
```
